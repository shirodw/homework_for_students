Иногда наши приложения вырастают из простых пет-проектов, в нечто действительно масштабное.
Мы уже не можем просто так залезть в код, логически догадаться, что пошло не так, и исправить проблемы.
Из-за огромного потока пользователей и большой кодовой базы, без вспомогательных инструментов мы рискуем 
потерять контроль над приложением.

Большого количества проблем можно избежать с помощью нескольких инструментов:

1) логирование - вы записываете в какое-то хранилище информацию о том, что произошло в вашей системе при определенных действиях или событиях.
К примеру:
```python
def save_user(user: User):
    try:
        storage.save(user)
        logger.info("success create user", user.id)
    except Exception as e:
        logger.error("error in time create user", e)
```

2) Метрики - метрики, это такие сущности, которые помогают отвечать как на вопросы бизнеса, так и на вопросы жизнедеятельности системы.
Подробнее можно [почитать вот тут](https://habr.com/ru/companies/tochka/articles/683608/) и [тут](https://cloud.vk.com/blog/chto-takoe-monitoring-i-ego-urovni)
Как это может выглядеть в коде?

```python
def save_user(user: User):
    try:
        storage.save(user)
        metrics.incr("aut_service.create_user.success")
    except Exception as e:
        metrics.incr("aut_service.create_user.fail")
```

Что произошло выше? мы увеличили метрику, в зависимости от того, какое событие у нас произошло. 
В идеале мы всегда должны создавать пользователей без ошибок, и на наших графиках с метриками мы будем видеть какое-то стабильное усредненное значение.
Ошибки, наоборот, всегда будут в нуле.
Но если вдруг что-то случается с нашим приложением, графики резко поменяются местами. Количество ошибок взметнется вверх, а количество успешных запросов стремительно упадет вниз.
Глядя на эти метрики, и настроив оповещения на их изменения, мы сможем предотвратить ужасные последствия подобной проблемы, оперативно загрузив исправления на сервис.

Мы немного погрузились в доменную область, теперь поговорим о задании.

Мы хотим реализовать функционал, который позволит записывать метрики в хранилище.
В нашем случае функционал очень ограничен. Мы можем записывать либо increment метрики, либо decrement метрики.
Записывать данные мы также будем не в специализированное хранилище по типу баз данных временных рядов, а в обычный файл. Каждое новое значение метрики должно быть записано в конец файла. Далее продемонстрирую это более подробно.

Что нужно сделать? 

* Необходимо реализовать класс Statsd, который позволяет создавать метрики.
* Класс Statsd позволяет записывать значения для метрик с заданным именем, инкрементируя их, или декрементируя.
* Класс Statsd не ходит в хранилище при каждом использовании методов incr и decr, он должен аккумулировать какое-то количество метрик, и по достижению границы эвакуировать их в хранилище.
* Класс Statsd должен позволять сохранять метрики либо в .txt файл, либо в .csv файл на выбор клиента этого класса.

Пример работы с классом:
```python
def get_csv_statsd(path: str, buffer: int = 10) -> Statsd:
    pass


def get_txt_statsd(path: str, buffer: int = 10) -> Statsd:
    pass

# Тут я могу выбрать любой способ хранения.
statsd = get_txt_statsd("./path/to/metrics.txt")
# statsd = get_csv_statsd("./path/to/metrics.csv")

for _ in range(10):
    statsd.incr("auth_service.create_user.success")
    time.sleep(1)


for _ in range(10):
    statsd.decr("auth_service.create_user.success")
    time.sleep(1)
```

Так как мы в обоих случаях заполнили буфер, то все метрики попали в хранилище на момент завершения программы. На выходе в нашем хранилище (файле), должна быть информация следующего вида (Время в UTC):
```md
2024-09-17T14:30:44+0000 auth_service.create_user.success 1
2024-09-17T14:31:44+0000 auth_service.create_user.success 1
...
2024-09-17T14:40:44+0000 auth_service.create_user.success 1

2024-09-17T14:41:44+0000 auth_service.create_user.success -1
2024-09-17T14:42:44+0000 auth_service.create_user.success -1
...
2024-09-17T14:51:44+0000 auth_service.create_user.success -1
```

Если мы говорим о csv файле, то информация должна храниться в виде:
```csv
date;metric;value
2024-09-17T14:30:44+0000;auth_service.create_user.success;1
2024-09-17T14:31:44+0000;auth_service.create_user.success;1
...
2024-09-17T14:40:44+0000;auth_service.create_user.success;1

2024-09-17T14:41:44+0000;auth_service.create_user.success;-1
2024-09-17T14:42:44+0000;auth_service.create_user.success;-1
...
2024-09-17T14:51:44+0000;auth_service.create_user.success;-1
```

Если бы мы написали такой код, то по заверщению программы файл с метриками должен оказаться пустым. Мы не заполнили весь буфер.:
```python
def get_txt_statsd(path: str, buffer: int = 10) -> Statsd:
    pass

# Тут я могу выбрать любой способ хранения.
statsd = get_txt_statsd("./path/to/metrics.txt")
# statsd = get_csv_statsd("./path/to/metrics.csv")

for _ in range(5):
    statsd.incr("auth_service.create_user.success")
    time.sleep(1)
```


Помимо этого нам хочется, чтобы класс предоставлял возможность "безопасно" эвакуировать метрики, которые записывались в выделенном блоке кода.
Это может пригодится, когда мы пишем что-то очень важное. И нам важен сам факт, что мы в принципе начали делать то, что мы делаем.
Пример:
```python
statsd = get_txt_statsd("./path/to/metrics.txt")

statsd.incr("auth_service.create_user.success")
time.sleep(1)
with statsd as sd:
    statsd.incr("auth_service.pay_salary.try")
    time.sleep(1)
    _ = 10 / 0
    statsd.incr("auth_service.pay_salary.success")
```
На выходе в нашем хранилище (файле), должна быть информация следующего вида:
```md
2024-09-17T14:30:44+0000 auth_service.create_user.success 1
2024-09-17T14:31:44+0000 auth_service.pay_salary.try 1
```

Как вы можете увидеть, несмотря на то, что буффер не заполнился, мы все равно записали значения в базу.

По итогу вам необходимо:
* реализовать класс Statsd, с которым можно работать так, как показано в примерах выше. Также можете обратиться к файлу с тестами, там будет пример ожидаемого поведения класса.
* внутри вашего класса не должно быть if, match..case, которые позволили бы определить, в какой тип хранилища мы сохраняем метрики. Это намек на то, что сохранением должна заниматься другая сущность и мы должны использовать композицию для делегирования этой задачи в другой класс.
* задание будет считаться принятым, если у вас прошли все тесты и код statsd универсально подходит как для одного хранилища, так и для другого. Если я захочу добавить еще один вид хранилища, то код самого Statsd не должен измениться.
